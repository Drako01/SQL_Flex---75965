# Transacciones y BackUp en SQL

## üß† ¬øQu√© es una Transacci√≥n en SQL?

Una **transacci√≥n** es un conjunto de instrucciones SQL que se ejecutan como una **unidad indivisible** de trabajo.

### üìå Caracter√≠sticas clave

* Todas las instrucciones dentro de la transacci√≥n deben **ejecutarse con √©xito**.
* Si ocurre un error, se puede **cancelar todo** (rollback).
* Solo cuando estamos seguros, se **confirma todo** con un commit.

Es como escribir un documento de Word:

* Vas escribiendo (como insertar datos).
* Pod√©s guardar cambios (commit) o deshacer los √∫ltimos cambios (rollback).

---

## üõ†Ô∏è PASO A PASO DEL EJEMPLO

### 1. **Creamos la base de datos y usamos esa base**

```sql
CREATE DATABASE IF NOT EXISTS coderhouse3;
USE coderhouse3;
```

> ‚úÖ Esto crea una base de datos llamada `coderhouse3` y selecciona esa base para trabajar.

---

### 2. **Creamos las tablas**

```sql
CREATE TABLE alumnos (...)
CREATE TABLE cursos (...)
CREATE TABLE inscripciones (...)
```

> ‚úÖ Estas instrucciones crean las tablas donde vamos a guardar:

* `alumnos`: informaci√≥n personal.
* `cursos`: lista de cursos disponibles.
* `inscripciones`: qui√©n se anot√≥ a qu√© curso.

La tabla `inscripciones` usa **claves for√°neas (FOREIGN KEY)** para conectar alumnos y cursos.

---

### 3. **Agregamos algunos datos**

---

### ‚úÖ Objetivo

* Evitar inscripciones duplicadas.
* Insertar una nueva inscripci√≥n si no existe.
* Retornar un mensaje indicando el resultado.
* Poder ser usado dentro de una transacci√≥n de forma segura.

---

### üì¶ Estructura esperada

Las tablas utilizadas son las que definiste antes:

* `alumnos(id_alumno)`
* `cursos(id_curso)`
* `inscripciones(id_alumno, id_curso, inscription_at)`

---

### üß† Procedimiento: `inscribir_alumno_seguro`

```sql
DELIMITER //

CREATE PROCEDURE inscribir_alumno_seguro(IN p_id_alumno INT, IN p_id_curso INT)
BEGIN
    DECLARE existe_alumno INT DEFAULT 0;
    DECLARE existe_curso INT DEFAULT 0;
    DECLARE existe_inscripcion INT DEFAULT 0;

    -- Validar si el alumno existe
    SELECT COUNT(*) INTO existe_alumno
    FROM alumnos
    WHERE id_alumno = p_id_alumno;

    -- Validar si el curso existe
    SELECT COUNT(*) INTO existe_curso
    FROM cursos
    WHERE id_curso = p_id_curso;

    -- Si no existe el alumno o el curso, mostrar mensaje de error y finalizar
    IF existe_alumno = 0 THEN
        SELECT '‚ùå El alumno no existe.' AS mensaje;
    ELSEIF existe_curso = 0 THEN
        SELECT '‚ùå El curso no existe.' AS mensaje;
    ELSE
        -- Verificar si ya est√° inscrito
        SELECT COUNT(*) INTO existe_inscripcion
        FROM inscripciones
        WHERE id_alumno = p_id_alumno AND id_curso = p_id_curso;

        IF existe_inscripcion > 0 THEN
            SELECT '‚ö†Ô∏è El alumno ya est√° inscrito en este curso.' AS mensaje;
        ELSE
            INSERT INTO inscripciones (id_alumno, id_curso)
            VALUES (p_id_alumno, p_id_curso);
            SELECT '‚úÖ Inscripci√≥n realizada correctamente.' AS mensaje;
        END IF;
    END IF;
END;
//

DELIMITER ;

```

---

### ‚úÖ ¬øC√≥mo usarlo?

```sql
CALL inscribir_alumno_seguro(1, 2);
```

Este ejemplo intenta inscribir al alumno con `id = 1` en el curso con `id = 2`.

---

### üß© Usarlo dentro de una transacci√≥n

Pod√©s incluir este procedimiento dentro de una transacci√≥n sin problemas:

```sql
START TRANSACTION;

CALL inscribir_alumno_seguro(1, 2);

-- Pod√©s agregar m√°s instrucciones aqu√≠...

COMMIT;
```

---

### üìå Notas

* Este procedimiento es una forma **segura y recomendada** de manejar l√≥gica con modificaciones (`INSERT`) en la base de datos.
* Puede ser usado dentro de una transacci√≥n, lo cual permite agrupar m√∫ltiples operaciones de forma at√≥mica.
* Si necesit√°s, se puede extender para validar si el alumno o curso existen antes de intentar inscribir.
* Retorna un mensaje de √©xito o advertencia mediante un `SELECT`, que puede ser capturado por el cliente (Workbench, PHP, Java, etc.).

---

> ‚úÖ Insertamos 3 alumnos y 3 cursos. Ya tenemos datos con los cuales trabajar.

---

### 4. **Iniciamos la Transacci√≥n**

```sql
START TRANSACTION;
```

> üîÑ Ac√° comienza **la transacci√≥n**. Todo lo que hagamos despu√©s **no ser√° permanente** hasta que usemos `COMMIT`. Si algo sale mal, podemos **deshacerlo**.

---

### 5. **Primer Inserci√≥n**

```sql
INSERT INTO inscripciones (id_alumno, id_curso) VALUES (1,1);
SAVEPOINT despues_del_primero;
```

> ‚úçÔ∏è Inscribimos al alumno 1 en el curso 1.
> üíæ Creamos un **punto de guardado** llamado `despues_del_primero`, por si queremos volver a este estado.

---

### 6. **Segunda Inserci√≥n**

```sql
INSERT INTO inscripciones (id_alumno, id_curso) VALUES (2,1);
SAVEPOINT despues_del_segundo;
```

> ‚úçÔ∏è Inscribimos al alumno 2 en el curso 1.
> üíæ Creamos otro punto de guardado.

---

### 7. **Tercera Inserci√≥n**

```sql
INSERT INTO inscripciones (id_alumno, id_curso) VALUES (3,1);
SAVEPOINT despues_del_tercero;
```

> ‚úçÔ∏è Inscribimos al alumno 3 en el curso 1.
> üíæ Guardamos el estado nuevamente.

---

### 8. **Cuarta Inserci√≥n (Error)**

```sql
INSERT INTO inscripciones (id_alumno, id_curso) VALUES (1,4);
SAVEPOINT despues_del_cuarto;
```

> ‚ö†Ô∏è **Error probable**: No existe el curso con `id_curso = 4`, ya que solo creamos cursos con ID 1, 2 y 3.
> üõë Esto **romper√≠a la transacci√≥n** si no la manejamos bien.

---

### 9. **Deshacemos el √∫ltimo paso**

```sql
ROLLBACK TO despues_del_tercero;
```

> üîô Deshacemos **todo lo que vino despu√©s del SAVEPOINT `despues_del_tercero`**, o sea: la cuarta inserci√≥n fallida.

---

### 10. **Confirmamos los cambios**

```sql
COMMIT;
```

> üíæ Todo lo que hicimos **hasta el punto `despues_del_tercero` se guarda de forma permanente** en la base de datos.
> Ya no se puede deshacer desde ac√°.

---

## üí° ¬øQu√© aprendemos con este ejemplo?

1. Las transacciones permiten controlar **qu√© cambios se guardan** y **cu√°les se descartan**.
2. Los **SAVEPOINTS** nos permiten **volver a un punto espec√≠fico** sin deshacer toda la transacci√≥n.
3. El **ROLLBACK** sirve para **revertir errores** sin afectar lo que ya estaba bien.
4. El **COMMIT** es lo que **confirma y guarda todo de forma definitiva**.

---

## üîÑ Ejemplo ampliado

Agreguemos un ejemplo con m√°s cursos y un rollback total:

```sql
START TRANSACTION;

-- Inscribimos varios alumnos
CALL inscribir_alumno_seguro(1, 2); -- OK
CALL inscribir_alumno_seguro(2, 2); -- OK
CALL inscribir_alumno_seguro(3, 5); -- ERROR (no existe curso 5)

ROLLBACK; -- Cancelamos todo

-- Ninguna inscripci√≥n fue guardada.
```

> ‚úÖ Como ocurri√≥ un error en el √∫ltimo paso, decidimos **cancelar toda la transacci√≥n**.
> Esto asegura que la base de datos **nunca quede en un estado incorrecto o incompleto**.

---

## ‚úÖ RESUMEN VISUAL

| Comando SQL          | ¬øQu√© hace?                                 |
| -------------------- | ------------------------------------------ |
| `START TRANSACTION`  | Inicia una transacci√≥n                     |
| `SAVEPOINT nombre`   | Crea un punto intermedio de guardado       |
| `ROLLBACK TO nombre` | Revierte hasta ese punto, sin borrar todo  |
| `ROLLBACK`           | Revierte toda la transacci√≥n completa      |
| `COMMIT`             | Guarda todos los cambios de la transacci√≥n |

---

## Ejemplos

Vamos con un **paso a paso**, de un ejemplo **con y sin `SAVEPOINT`**, adem√°s de una tabla comparativa con **ventajas y desventajas**.

---

## üìò **EJEMPLO 1: Transacci√≥n SIN `SAVEPOINT`**

```sql
START TRANSACTION;

-- Supongamos que existen los cursos con ID 1, 2 y 3
-- y los alumnos con ID 1, 2 y 3

-- Inscripciones v√°lidas
CALL inscribir_alumno_seguro(1, 1);
CALL inscribir_alumno_seguro(2, 2);

-- Inserci√≥n con error (curso 99 no existe)
CALL inscribir_alumno_seguro(3, 99);

-- Al detectar el error, revertimos todo
ROLLBACK;

-- Nada de lo anterior fue guardado
```

üß† **¬øQu√© pas√≥?**

* Los dos primeros `INSERT` eran correctos.
* El tercero fall√≥.
* Con `ROLLBACK` **se cancel√≥ todo**, aunque hab√≠a operaciones v√°lidas.

---

## üìó **EJEMPLO 2: Transacci√≥n CON `SAVEPOINT`**

```sql
START TRANSACTION;

-- Primer inscripci√≥n v√°lida
CALL inscribir_alumno_seguro(1, 1);
SAVEPOINT paso_1;

-- Segunda inscripci√≥n v√°lida
CALL inscribir_alumno_seguro(2, 2);
SAVEPOINT paso_2;

-- Tercer inscripci√≥n con error
CALL inscribir_alumno_seguro(3, 99); -- curso 99 no existe

-- Volvemos al punto anterior
ROLLBACK TO paso_2;

-- Confirmamos los dos primeros inserts
COMMIT;
```

üß† **¬øQu√© pas√≥?**

* El error fue revertido sin borrar todo lo anterior.
* Se guardaron las dos primeras inscripciones.
* La inscripci√≥n fallida fue descartada.

---

## ‚öñÔ∏è **Ventajas y Desventajas de usar `SAVEPOINT`**

| üß© Caracter√≠stica              | CON `SAVEPOINT`                                    | SIN `SAVEPOINT`                            |
| ------------------------------ | -------------------------------------------------- | ------------------------------------------ |
| üéØ Control de errores          | Muy preciso. Pod√©s volver a un paso intermedio     | Poca flexibilidad: todo o nada             |
| üíæ Datos salvados parcialmente | S√≠, pod√©s guardar lo v√°lido y descartar lo err√≥neo | No, se pierde todo si hay un solo error    |
| üß† Complejidad del c√≥digo      | M√°s complejo de escribir y entender                | M√°s simple                                 |
| ‚è±Ô∏è Tiempo de ejecuci√≥n         | Ligeramente mayor si us√°s muchos savepoints        | M√°s r√°pido, pero menos seguro              |
| üõ°Ô∏è Seguridad de los datos     | M√°s seguro ante errores puntuales                  | Riesgoso si no control√°s todos los errores |

---

## üìù Conclusi√≥n clara para principiantes

* Si **ten√©s pocos pasos** y **quer√©s simplicidad**, us√° transacciones normales sin `SAVEPOINT`.
* Si **est√°s haciendo muchas operaciones** y quer√©s evitar perder todo por un solo error, **us√° `SAVEPOINT` y `ROLLBACK TO`**.

---

## BackUp

---

## üíæ ¬øQu√© es un BACKUP?

> Un **backup** (o **respaldo**) es una **copia de seguridad** de los datos de una base de datos. Sirve para **proteger la informaci√≥n** frente a errores humanos, fallos t√©cnicos, ataques inform√°ticos o cualquier otro imprevisto.

---

## üéØ ¬øPara qu√© sirve un BACKUP?

| ‚úÖ Usos del backup                      | üß† Ejemplos reales                       |
| -------------------------------------- | ---------------------------------------- |
| Recuperar informaci√≥n perdida          | Se borr√≥ una tabla por accidente         |
| Restaurar sistema tras una ca√≠da       | Se apag√≥ el servidor sin guardar cambios |
| Migrar datos a otro servidor           | Cambiar de hosting o infraestructura     |
| Hacer pruebas sin afectar datos reales | Crear una copia y probar sobre esa copia |

---

## üîÑ Tipos de Backup

| Tipo de Backup     | Qu√© guarda                                    | Ventajas                   | Desventajas                   |
| ------------------ | --------------------------------------------- | -------------------------- | ----------------------------- |
| üü¢ Completo (Full) | Toda la base de datos                         | F√°cil de restaurar         | Requiere mucho espacio        |
| üü° Incremental     | Solo lo que cambi√≥ desde el **√∫ltimo backup** | R√°pido, usa poco espacio   | Restaurar puede ser complejo  |
| üîµ Diferencial     | Cambios desde el **√∫ltimo backup completo**   | M√°s r√°pido que el completo | M√°s grande que el incremental |

---

## ‚öôÔ∏è ¬øC√≥mo se hace un BACKUP en MySQL?

### üìå 1. Usando la l√≠nea de comandos (con `mysqldump`)

```bash
mysqldump -u usuario -p nombre_de_base > respaldo.sql
```

üìå Ejemplo:

```bash
mysqldump -u root -p coderhouse3 > backup_coderhouse3.sql
```

‚úÖ Esto genera un archivo de texto (`.sql`) que contiene todas las instrucciones necesarias para **recrear la base de datos**, incluyendo:

* CREATE TABLE
* INSERT INTO
* Estructura y datos

---

### üìå 2. Restaurar un backup (con `mysql`)

```bash
mysql -u usuario -p nombre_de_base < respaldo.sql
```

üìå Ejemplo:

```bash
mysql -u root -p coderhouse3 < backup_coderhouse3.sql
```

---

### üìå 3. Desde MySQL Workbench

Si us√°s Workbench (interfaz gr√°fica):

* **Exportar backup**:

  * Men√∫: `Server` > `Data Export`
  * Seleccion√°s la base de datos
  * Eleg√≠s "Export to Self-Contained File"
  * Guard√°s el `.sql`

* **Importar backup**:

  * Men√∫: `Server` > `Data Import`
  * Eleg√≠s el archivo `.sql`
  * Seleccion√°s la base destino o cre√°s una nueva
  * Ejecut√°s

---

## üß™ Ejemplo pr√°ctico paso a paso

1. Ten√©s una base llamada `coderhouse3`.
2. Quer√©s hacer un backup antes de probar algo riesgoso.

```bash
mysqldump -u root -p coderhouse3 > antes_del_experimento.sql
```

3. Ahora prob√°s algo que da√±a los datos (borr√°s todo por error):

```sql
DROP TABLE alumnos;
```

4. ¬°Ups! Pero como hiciste backup, lo recuper√°s as√≠:

```bash
mysql -u root -p coderhouse3 < antes_del_experimento.sql
```

‚úÖ ¬°Listo! Recuperaste todo como estaba.

---

## üíæ ¬øQu√© es un Backup en MySQL?

Un **Backup** es una **copia de seguridad** de una base de datos. Sirve para **proteger los datos** en caso de errores humanos, fallas del sistema, corrupci√≥n de archivos, etc.

En MySQL, los backups se suelen guardar como archivos `.sql` que contienen todas las instrucciones necesarias para **recrear la base de datos, sus tablas y sus datos**.

---

## üõ† C√≥mo hacer un Backup en MySQL Workbench (paso a paso)

### ‚úÖ Paso 1: Abrir MySQL Workbench

* Inici√° **MySQL Workbench** y conectate a tu servidor MySQL.

---

### ‚úÖ Paso 2: Ir a la herramienta de exportaci√≥n

* En el men√∫ superior, hac√© clic en:
  **Server ‚Üí Data Export**

---

### ‚úÖ Paso 3: Elegir la base de datos a respaldar

* En la parte izquierda, vas a ver todas las bases de datos disponibles.
* Seleccion√° la base de datos que quer√©s exportar (por ejemplo: `coderhouse3`).

---

### ‚úÖ Paso 4: Elegir qu√© exportar

* Pod√©s marcar:

  * ‚úÖ Toda la base de datos (todos los objetos)
  * ‚úÖ O solo algunas tablas.

* Luego, marc√° la opci√≥n:

  * üîò **Export to Self-Contained File**
    Esto genera un √∫nico archivo `.sql`.

* Eleg√≠ la **ruta de destino** y el **nombre del archivo** (`coderhouse3_backup.sql`, por ejemplo).

---

### ‚úÖ Paso 5: Opciones adicionales

* Asegurate que est√© marcada la opci√≥n:

  * ‚úÖ **Include Create Schema**
  * ‚úÖ **Dump Structure and Data**

Esto asegura que el archivo incluir√° tanto las estructuras (tablas, etc.) como los datos.

---

### ‚úÖ Paso 6: Iniciar el proceso

* Hac√© clic en el bot√≥n **Start Export** (abajo a la derecha).
* Esper√° unos segundos hasta que aparezca el mensaje de **‚ÄúExport completed successfully‚Äù**.

---

## üìÇ ¬øQu√© obtengo?

Un archivo `.sql` con todo el contenido de tu base de datos. Este archivo se puede usar luego para restaurar la base, incluso en otro servidor.

---

## üí° Recomendaciones

* Hac√© backups **frecuentemente**, especialmente antes de hacer cambios grandes.
* Guard√° los backups en lugares **seguros** (disco externo, nube, etc.).
* Prob√° restaurar el backup de vez en cuando para verificar que funciona.

---

## **paso a paso para restaurar** ese backup en Workbench?

## üîÅ ¬øQu√© es Restaurar una Base de Datos?

Restaurar una base de datos es **recuperar los datos y estructuras** desde un archivo de backup `.sql`. Es √∫til cuando:

* Perdiste datos por error.
* Quer√©s mover la base a otro servidor.
* Necesit√°s rehacer una base con datos previos.

---

## üõ† C√≥mo Restaurar un Backup en MySQL Workbench (paso a paso)

### ‚úÖ Paso 1: Abrir MySQL Workbench

* Abr√≠ **MySQL Workbench** e inici√° sesi√≥n en tu servidor.

---

### ‚úÖ Paso 2: Ir a la herramienta de importaci√≥n

* En el men√∫ superior, hac√© clic en:
  **Server ‚Üí Data Import**

---

### ‚úÖ Paso 3: Seleccionar el archivo de backup

* En la secci√≥n "Import Options", eleg√≠:

  * üîò **Import from Self-Contained File**
* Luego, busc√° el archivo `.sql` que hiciste en el backup (por ejemplo, `coderhouse3_backup.sql`).

---

### ‚úÖ Paso 4: Elegir d√≥nde restaurarlo

* En la secci√≥n ‚ÄúDefault Target Schema‚Äù, seleccion√° la base de datos destino.

**¬øNo existe la base de datos a√∫n?**

1. Hac√© clic en **‚ÄúNew‚Äù** para crear una base nueva.
2. Pon√© un nombre (por ejemplo: `coderhouse3_restaurada`).
3. Hac√© clic en **‚ÄúOK‚Äù** y seleccionala como destino.

---

### ‚úÖ Paso 5: Opciones de importaci√≥n

* Asegurate de tener marcada la opci√≥n:

  * ‚úÖ **Dump Structure and Data**

---

### ‚úÖ Paso 6: Ejecutar la importaci√≥n

* Hac√© clic en **Start Import**.
* Esper√° que se complete el proceso. Deber√≠a decir ‚ÄúImport Completed Successfully‚Äù.

---

## üîé Verificar que la restauraci√≥n fue exitosa

* En el panel izquierdo (Schema), actualiz√° los esquemas.
* Busc√° la base restaurada.
* Revis√° las tablas, datos, y prob√° algunas consultas.

---

## üìå Recomendaciones

* Restaur√° en un entorno de prueba antes de hacerlo en producci√≥n.
* Siempre verific√° que el archivo `.sql` est√© completo.
* No interrumpas el proceso una vez iniciado.

---

## üõ°Ô∏è Buenas pr√°cticas con Backups

| Consejo                                        | Por qu√© es √∫til                                      |
| ---------------------------------------------- | ---------------------------------------------------- |
| üïì Hacer backups diarios o semanales           | Para minimizar p√©rdida de informaci√≥n                |
| üåê Guardar copias en la nube o discos externos | Evita perder todo si falla tu PC o servidor          |
| üìÑ Documentar los pasos para restaurar         | Ayuda en caso de emergencia                          |
| üîí Proteger los archivos de backup             | Contienen datos sensibles (us√° contrase√±as, cifrado) |
| ‚úÖ Probar la restauraci√≥n de vez en cuando      | Asegura que el backup funciona realmente             |

---

## üéì Conclusi√≥n sencilla

* Un backup es como un **seguro** para tus datos.
* Es **obligatorio** en proyectos profesionales.
* Se hace f√°cil con herramientas como `mysqldump` o Workbench.
* Es mejor tener **un backup que no necesit√°s** que necesitar uno que no hiciste.

---

## üßë‚Äçüè´ Profesor  

üë®‚Äçüíª **Alejandro Daniel Di Stefano**  
üìå **Desarrollador Full Stack**  
üîó **GitHub:** [Drako01](https://github.com/Drako01)  
